# SenderCode

### 版本内容更新

#### V0.2.0更新

1. 将串口通信接收的数据，由归一化后的数据（即0101……）改为原始数据

2. 增加了split函数，能够将串口的数据进行分割了

#### V0.3.0 - V0.3.2

<font color=#FF0000 face="黑体" size=4>**！！！V0.3.0 - V0.3.2 存在重大未修复bug，请勿使用！！！\
bug已经在0.3.3中解决。**</font>

#### V0.3.3

1. 重构了数据接收的代码。

2. 使用中断来操作主站的串口发送，优化串口通信：
    使用D1引脚（GPIO5）作为主站串口发送的外部中断。首先发送站读取数据前将D1置低，再置高，给主站一个上升沿，主站发送数据，发送站延迟等待发送结束，延迟结束后读取数据，读完后再进入下一轮，不断循环。

3. 优化了串口监视，将分界线放在了函数内，位置更加正确，监视信息更加明了。

4. 添加宏定义

    ```
    #define RequestIntervalTime 1000      //请求间隔时间
    #define LoopDelayTime 100     //循环一次，即接收一次串口数据间隔的时间
    #define ReadDataTime 100    //等待读取完毕串口数据的时间
    ```

   使以后的更改更加方便

5. 优化代码，减少不必要的delay，能够更加精准地控制时间了。

#### V0.3.4

1. 优化了时间控制，使用millis函数来获取开机后运行的时间长度，从而控制http请求的间隔时间，比以前的控制更加精准（实际上以前的时间控制很不精准）。

2. 删除了

    ```
   #define LoopDelayTime 100     //循环一次，即接收一次串口数据间隔的时间
    ```

    并删除了loop函数中的延迟，因为更改了时间控制方法后这个不再需要

3. 适当降低了串口通信获取数据的频率，改为只在发送http请求前获取一次数据。

4. 经过试验文件0.0.3.4中的实验，此文件在删除串口打印情况下，最快可以大约每350ms发送一次请求。

5. 此版本暂时满足请求频率，若要在以后继续增加请求频率，则可以在等待串口通信完成时间等位置动手脚。 

   需要注意的是，若继续增加频率，则要考虑数据的及时性，即从站发送数据速度是否跟得上发送站发送频率，这就又要考虑从站功耗的问题。
   从站通过ESPNOW发送数据，限制时间最大的问题在于当前的休眠算法需要一段时间来检测是否休眠，大约300ms。
   增加发送频率则要对休眠检测算法进行优化，大致思路为：
   休眠唤醒后的就坐使用现有的算法。
   有人坐后，使用另一套延迟较低的检测算法，若检测到就坐的人离开，几秒过后若仍无人就坐，再休眠。

   注：若需要使用复位后不丢失的数据，则要使用EEPROM库。